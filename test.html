<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Cube • Base + Bloom → Composite</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html { margin:0; height:100%; background:#101014; }
  body {
    background: none;
    display:grid; place-items:center;
  }
  .stage { width:100%; height:100%; position:relative; }
  canvas { width:100%; height:100%; display:block; }
</style>

<!-- Mix shader (base + bloom) -->
<script id="mix-vs" type="x-shader/x-vertex">
  varying vec2 vUv;
  void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="mix-fs" type="x-shader/x-fragment">
  uniform sampler2D baseTexture;
  uniform sampler2D bloomTexture;
  varying vec2 vUv;
  void main(){
    vec4 base  = texture2D(baseTexture,  vUv);
    vec4 bloom = texture2D(bloomTexture, vUv);
    gl_FragColor = vec4(base.rgb + 0.5*bloom.rgb, 1.0);//  min(base.a, 1.0));   // additive composite
    //gl_FragColor = bloom;
  }
</script>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>

<div class="stage" id="stage"></div>

<!-- Background controls (small overlay) -->
<div id="bg-controls" style="position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.45);color:#fff;padding:6px 8px;border-radius:6px;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-size:13px;z-index:10;display:flex;align-items:center;gap:8px;">
  <button id="bg-prev" title="Previous background" style="background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer">◀</button>
  <div id="bg-label">Background</div>
  <button id="bg-next" title="Next background" style="background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff;padding:4px 8px;border-radius:4px;cursor:pointer">▶</button>
  <!-- integer slider 0..10 for blending across available background textures -->
  <input id="bg-blend" type="range" min="0" max="10" step="0.1" value="0" title="Background blend" style="width:140px;margin-left:8px">
</div>

<!-- Bloom controls (expose strength, radius, threshold) -->
<div id="bloom-controls" style="position:fixed;right:12px;top:84px;background:rgba(0,0,0,0.45);color:#fff;padding:8px 10px;border-radius:8px;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;font-size:13px;z-index:10;display:flex;flex-direction:column;gap:8px;min-width:220px;">
  <div style="display:flex;justify-content:space-between;align-items:center;">
    <strong>Bloom</strong>
    <span style="font-variant-numeric:tabular-nums;"><span id="bloom-strength-val">0</span> / <span id="bloom-radius-val">0</span> / <span id="bloom-threshold-val">0</span></span>
  </div>
  <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;">Strength <input id="bloom-strength" type="range" min="0" max="5" step="0.01" value="1"></label>
  <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;">Radius <input id="bloom-radius" type="range" min="0" max="5" step="0.01" value="0.5"></label>
  <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;">Threshold <input id="bloom-threshold" type="range" min="0" max="5" step="0.01" value="0.1"></label>
  <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;">Hue speed <input id="hue-speed" type="range" min="0" max="1" step="0.001" value="0.0"></label>
  <label style="display:flex;flex-direction:column;gap:4px;font-size:12px;">Hue saturation <input id="hue-sat" type="range" min="0" max="1" step="0.01" value="1.0"></label>
</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer }  from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass }      from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass }      from 'three/addons/postprocessing/ShaderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass }      from 'three/addons/postprocessing/OutputPass.js';
import { GLTFLoader }      from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader }     from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
import { OrbitControls }   from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

const container = document.getElementById('stage');

// ---------- Renderer ----------
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

// ---------- Scene / camera ----------
const scene = new THREE.Scene();
// ---------- Bloom exclusion list ----------
// List object names to exclude from the bloom pass (they will still render in the final pass)
// Edit this array to match names in your GLTF (e.g. ['Char', 'NoBloom'])
const bloomExclude = ['Base001', 'Base'];

// Internal storage for original visibility states when toggling bloom exclusion
const _bloomHidden = [];
function hideBloomExcluded(){
  _bloomHidden.length = 0;
  for (let name of bloomExclude){
    const obj = scene.getObjectByName(name);
    if (obj){
      _bloomHidden.push({ obj, visible: obj.visible });
      obj.visible = false;
    }
  }
}
function restoreBloomExcluded(){
  for (let rec of _bloomHidden) rec.obj.visible = rec.visible;
  _bloomHidden.length = 0;
}

// ---------- Background images (cycleable) ----------
// Provide a small set of images (from ./img/) and let the user pick via ?bg=N
const bgPaths = [
  './img/sky01.png',
  './img/sky02.png',
  './img/sky03.png',
  './img/sky04.png'
];
const texLoader = new THREE.TextureLoader();
const bgTextures = bgPaths.map(p => texLoader.load(p));
// ensure correct color space for textures when available
bgTextures.forEach(t => { try { if (t) t.colorSpace = THREE.SRGBColorSpace; } catch(e){} });
// --- shader-driven background pass (will be inserted into composers later) ---
let bgPass = null;
function createBgPass(){
  // use the simple UV passthrough vertex shader already in the document
  const bgMat = new THREE.ShaderMaterial({
    uniforms: {
      t0: { value: bgTextures[0] },
      t1: { value: bgTextures[1] },
      uMix: { value: 0.0 },
      resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    },
    vertexShader: document.getElementById('mix-vs').textContent,
    fragmentShader: `
      varying vec2 vUv;
      uniform sampler2D t0;
      uniform sampler2D t1;
      uniform float uMix;
      void main(){
        vec2 uv = vUv;
        vec4 a = texture2D(t0, uv);
        vec4 b = texture2D(t1, uv);
        // if(vUv.x < 0.5){
        //   // left half: show texture A
        //   gl_FragColor = a;
        //   return;
        // } else {
        //   // right half: show texture B
        //   gl_FragColor = b;
        //   return;
        // }
        gl_FragColor = mix(a, b, uMix);
      }
    `,
    depthWrite: false,
    depthTest: false,
    toneMapped: false
  });
  // create ShaderPass without a textureID so our t0/t1 uniforms are preserved
  bgPass = new ShaderPass(bgMat);
}

let bgIndex = 0;
const params = new URLSearchParams(window.location.search);
const initial = parseInt(params.get('bg'));
if (!Number.isNaN(initial) && initial >= 0 && initial < bgTextures.length) bgIndex = initial;

function setBackground(i){
  bgIndex = ((i % bgTextures.length) + bgTextures.length) % bgTextures.length;
  const tex = bgTextures[bgIndex];
  // if we have a shader-driven bgPass, prefer it (we'll still update the label)
  if (bgPass && bgPass.material && bgPass.material.uniforms){
    // snap slider to nearest step corresponding to this bgIndex
    const steps = Math.round((bgIndex / Math.max(1, bgTextures.length - 1)) * 10);
    const el = document.getElementById('bg-blend');
    if (el) el.value = steps;
    updateBgFromIntSlider(steps);
  } else {
    scene.background = tex || null;
  }
  const label = document.getElementById('bg-label');
  if (label) label.textContent = `Background ${bgIndex} — ${bgPaths[bgIndex].split('/').pop()}`;
  // keep body fallback empty so the canvas shows through
  document.body.style.background = 'none';
}

// wire up controls
setBackground(bgIndex);
window.addEventListener('keydown', (e)=>{
  if (e.key === 'ArrowRight') setBackground(bgIndex + 1);
  if (e.key === 'ArrowLeft') setBackground(bgIndex - 1);
});
const prevBtn = document.getElementById('bg-prev');
const nextBtn = document.getElementById('bg-next');
if (prevBtn) prevBtn.addEventListener('click', ()=> setBackground(bgIndex - 1));
if (nextBtn) nextBtn.addEventListener('click', ()=> setBackground(bgIndex + 1));

// const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
// camera.position.set(2,1.5,3);

const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.1, 100);
camera.position.set(0.8, 0.8, 1.8);
camera.lookAt(0,0,0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ---------- GLB model ----------
const loader = new GLTFLoader();
const draco  = new DRACOLoader();
draco.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
loader.setDRACOLoader(draco);

let rockMesh = null;
let charObj = null; // will hold object named "Char" if present
let _charBaseY = 0;
let _charBaseRotY = 0; // remember initial Y rotation so noise is applied relative to it

// Helper: try to find Char anywhere in the scene
function findCharInScene(){
  if (charObj) return charObj;
  const found = scene.getObjectByName('Char');
  if (found){
    charObj = found;
    _charBaseY = (charObj.position && typeof charObj.position.y === 'number') ? charObj.position.y : 0;
    _charBaseRotY = (charObj.rotation && typeof charObj.rotation.y === 'number') ? charObj.rotation.y : 0;
    charObj.matrixAutoUpdate = true;
    console.log('Found Char in scene, base Y =', _charBaseY);
  }
  return charObj;
}

// Lightweight multi-octave noise using sines (cheap, avoids extra libs). Returns roughly [-1,1]
function cheapNoise(t, seed=0){
  const s1 = Math.sin(t * 1.37 + seed * 12.34);
  const s2 = 0.6 * Math.sin(t * 2.73 + seed * 7.21);
  const s3 = 0.35 * Math.sin(t * 5.19 + seed * 3.11);
  return (s1 + s2 + s3) / (1.0 + 0.6 + 0.35);
}

function updateChar(t){
  if (!charObj) findCharInScene();
  if (!charObj) return;
  const seed = (charObj.id || 1) * 0.001;
  const freq = 0.1; // speed
  const amp = 1; // amplitude
  const n = cheapNoise(t * freq, seed);
  charObj.position.y = _charBaseY + n * amp;

  // --- side-to-side Y rotation driven by separate noise ---
  // rotate between -60 and +60 degrees (±PI/3 radians)
  const rotFreq = 0.12; // slightly slower rotation frequency
  const maxAngle = Math.PI / 4; // 60 degrees in radians
  const nRot = cheapNoise(t * rotFreq, seed + 37.0); // offset seed so rotation differs from vertical motion
  charObj.rotation.y = _charBaseRotY - Math.PI + nRot * maxAngle;
}
const rockMat = new THREE.ShaderMaterial({
  uniforms: {
    uTime:      { value: 0 },
    uColorA:    { value: new THREE.Color(0x736c61) },
    uColorB:    { value: new THREE.Color(0x94a18c) },
    uGlow:      { value: 1.3 },
    // hue controls for radial gradient (hueOffset in turns, hueScale multiplier)
    uHueOffset: { value: 0.0 },
    uHueScale:  { value: 1.0 },
    uHueSpeed:  { value: 0.3 },
    uHueSat:    { value: 0.5 },
    // how strongly the radial hue tints the edge
    uEdgeStrength: { value: 0.9 }
  },
  vertexShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 viewDir;
    void main(){
      // keep vPos for your banding pattern (object/model space scaled)
      vPos = position * 3.0;
      // transform normal into view space using normalMatrix so it matches viewDir space
      vNormal = normalize( normalMatrix * normal );
      // compute view direction in VIEW SPACE: camera is at origin in view space
      vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
      viewDir = normalize( -mvPos.xyz );

      gl_Position = projectionMatrix * mvPos;
    }
  `,
  fragmentShader: `
    varying vec3 vPos;
    varying vec3 vNormal;
    varying vec3 viewDir;
    uniform float uTime;
    uniform vec3  uColorA, uColorB;
    uniform float uGlow;
    // new uniforms for radial hue mapping
    uniform float uHueOffset;
    uniform float uHueScale;
    uniform float uEdgeStrength;
    uniform float uHueSat;
    uniform float uHueSpeed;

    // HSV -> RGB helper (full saturation/value supported)
    vec3 hsv2rgb(float h, float s, float v){
      // compact HSV->RGB: build a base rgb then mix toward white based on (1 - saturation)
      vec3 p = abs(fract(h + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
      vec3 rgb = clamp(p - 1.0, 0.0, 1.0);
      // mix between white (unsaturated) and rgb based on saturation, then scale by value
      return mix(vec3(1.0), rgb, s) * v;
    }

    void main(){
        vec3 N = normalize(vNormal);
        // vec3 I = normalize(-vPos);
        // vec3 V = normalize(cameraPos - FragPos);
      float bands = abs( sin(vPos.x) * sin(vPos.y) * sin(vPos.z) );
      float mask = smoothstep(0.2, 0.8, bands);
      vec3 base = mix(uColorA, uColorB, mask);
      float pulse = 0.5 + 0.5 * sin(uTime * 2.0);
      vec3 tint = vec3(
        1.0 + 0.06 * cos(uTime * 1.7),
        1.0 + 0.06 * cos(uTime * 1.1 + 1.57),
        1.0 + 0.06 * cos(uTime * 1.3 + 3.14)
      );
      float foo = dot(N, viewDir);
      vec3 color = base * tint;
      color += uGlow * pulse * vec3(0.6); // energy for bloom
      // --- Fresnel/edge component (radial hue mapping) ---
      // compute dot(normal, viewDir) and turn into an edge factor
      float ndotv = dot(N, normalize(viewDir));
      // fresnel-like response: edges where ndotv is small (grazing angles)
      float edge = pow(1.0 - clamp(ndotv, -1.0, 1.0), 2.0);

      // polar coordinates around object center: use vPos.x and vPos.z
      float angle = atan(vPos.y, vPos.x); // -PI..PI
      float hue = (angle / (6.28318530718)) + 0.5; // normalize to 0..1
      // apply uniforms for offset/scale
      hue = mod(hue + uHueOffset,1.0);

      vec3 radialHue = hsv2rgb(hue, uHueSat, 1.0);
      // apply edge strength and mix into color (additive tint)
      color = radialHue * uEdgeStrength * edge;
      color = radialHue * edge;
      // color = vec3(foo + 1.0) * 0.5;
      gl_FragColor = vec4(color, 1.0);
      // gl_FragColor = vec4(uHueSat, 0.0, 0.0, 1.0); // DEBUG
    }
  `
});


loader.load('./models/rock.glb', (gltf)=>{
  const root = gltf.scene;

  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  root.position.sub(center);
  const s = 1 / Math.max(size.x, size.y, size.z || 1e-6);
  root.scale.setScalar(s);

  root.traverse(o => { console.log(o.name); if (!rockMesh && o.isMesh && o.name == "Rock") rockMesh = o; });
  if (rockMesh) rockMesh.material = rockMat;

  scene.add(root);
}, undefined, err => console.error('GLB load error:', err));

// ---------- Simple content ----------
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshBasicMaterial({ color: 0xff4040 })
);
// scene.add(cube);

// (Directional light not needed for MeshBasicMaterial, but harmless)
scene.add(new THREE.HemisphereLight(0xffffff, 0x334455, 1.0));

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(2,3,2);
scene.add(light);

// Reusable render pass for both composers
const renderScene = new RenderPass(scene, camera);
renderScene.clear = true;
renderScene.clearAlpha = 0.0;

// ---------- Bloom composer (off-screen) ----------
const bloomComposer = new EffectComposer(renderer);
bloomComposer.renderToScreen = false;   // we will mix manually
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  /* strength  */ 1.2,
  /* radius    */ 1.0,
  /* threshold */ 0.1   // bloom everything so it’s obvious
);

// ensure bgPass exists and insert it first so it renders behind the scene
if (!bgPass) createBgPass();
// bloomComposer.addPass(bgPass);
bloomComposer.addPass(renderScene);
bloomComposer.addPass(bloomPass);

// --- Wire bloom UI sliders ---
const bloomStrengthEl = document.getElementById('bloom-strength');
const bloomRadiusEl = document.getElementById('bloom-radius');
const bloomThresholdEl = document.getElementById('bloom-threshold');
const bloomStrengthVal = document.getElementById('bloom-strength-val');
const bloomRadiusVal = document.getElementById('bloom-radius-val');
const bloomThresholdVal = document.getElementById('bloom-threshold-val');
if (bloomStrengthEl){
  bloomStrengthEl.value = bloomPass.strength;
  bloomStrengthVal.textContent = Number(bloomPass.strength).toFixed(2);
  bloomStrengthEl.addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    bloomPass.strength = v;
    bloomStrengthVal.textContent = v.toFixed(2);
  });
}
if (bloomRadiusEl){
  bloomRadiusEl.value = bloomPass.radius;
  bloomRadiusVal.textContent = Number(bloomPass.radius).toFixed(2);
  bloomRadiusEl.addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    bloomPass.radius = v;
    bloomRadiusVal.textContent = v.toFixed(2);
  });
}
if (bloomThresholdEl){
  bloomThresholdEl.value = bloomPass.threshold;
  bloomThresholdVal.textContent = Number(bloomPass.threshold).toFixed(2);
  bloomThresholdEl.addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    bloomPass.threshold = v;
    bloomThresholdVal.textContent = v.toFixed(2);
  });
}

// Wire hue controls
const hueSpeedEl = document.getElementById('hue-speed');
const hueSatEl = document.getElementById('hue-sat');
if (hueSpeedEl){
  hueSpeedEl.value = rockMat.uniforms.uHueSpeed.value;
  hueSpeedEl.addEventListener('input', (e)=>{
    rockMat.uniforms.uHueSpeed.value = Number(e.target.value);
  });
}
if (hueSatEl){
  hueSatEl.value = rockMat.uniforms.uHueSat.value;
  hueSatEl.addEventListener('input', (e)=>{
    rockMat.uniforms.uHueSat.value = Number(e.target.value);
  });
}

// ---------- Final composer (base + mix bloom + output) ----------
const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(renderScene);

// Mix pass: base comes from previous pass (textureID = 'baseTexture')
// Bloom comes from bloomComposer.renderTarget2.texture (same as example)
const mixPass = new ShaderPass(
  new THREE.ShaderMaterial({
    uniforms: {
      baseTexture:  { value: null }, // filled automatically by ShaderPass
      bloomTexture: { value: bloomComposer.renderTarget2.texture }
    },
    vertexShader:   document.getElementById('mix-vs').textContent,
    fragmentShader: document.getElementById('mix-fs').textContent
  }),
  'baseTexture'
);
mixPass.needsSwap = true;
// insert bgPass first in final composer as well
if (!bgPass) createBgPass();
// finalComposer.addPass(bgPass);  // TODO: Fix this stage to enable eyes AND background
finalComposer.addPass(mixPass);

// Output/gamma/tone mapping correction (same pattern as example)
finalComposer.addPass(new OutputPass());

// ---------- Resize ----------
function onResize(){
  const w = window.innerWidth, h = window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
  bloomComposer.setSize(w, h);
  finalComposer.setSize(w, h);
  bloomPass.setSize(w, h);
  if (bgPass && bgPass.material && bgPass.material.uniforms && bgPass.material.uniforms.resolution) bgPass.material.uniforms.resolution.value.set(w,h);
}
addEventListener('resize', onResize);

// --- map integer 0..10 slider to two texture indices and a local mix value ---
function updateBgFromIntSlider(steps){
    console.log("updateBgFromIntSlider:", steps);
  const s = Number(steps);
  const N = bgTextures.length;
  if (N === 0 || !bgPass || !bgPass.material || !bgPass.material.uniforms) return;
  const frac = (s / 10) * (N - 1);
  const i0 = Math.floor(frac);
  const i1 = Math.min(i0 + 1, N - 1);
  const localMix = frac - i0;
  bgPass.material.uniforms.t0.value = bgTextures[i0];
  bgPass.material.uniforms.t1.value = bgTextures[i1];
  bgPass.material.uniforms.uMix.value = localMix;
  const label = document.getElementById('bg-label');
  if (label) label.textContent = `Background ${i0}-${i1} mix ${localMix.toFixed(2)} - ${s/10} - ${frac}`;
}

const bgBlendEl = document.getElementById('bg-blend');
if (bgBlendEl){
  bgBlendEl.addEventListener('input', (e)=> updateBgFromIntSlider(Number(e.target.value)));
  updateBgFromIntSlider(Number(bgBlendEl.value));
}

// ---------- Loop ----------
const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
    controls.update();
  const t = clock.getElapsedTime();
//   cube.rotation.x = t * 0.7;
//   cube.rotation.y = t * 1.1;

  rockMat.uniforms.uTime.value = t;
  // advance hue offset by speed (wrap using fract)
  const dt = clock.getDelta();
  // wrap to [0,1)
//   let newOffset = rockMat.uniforms.uHueOffset.value + rockMat.uniforms.uHueSpeed.value*0.1;
//   newOffset = newOffset % 1;
//   console.log(" newOffset:", newOffset, " speed:", rockMat.uniforms.uHueSpeed.value, " dt:", dt);
    rockMat.uniforms.uHueOffset.value = t * rockMat.uniforms.uHueSpeed.value % 1.0;

  // Update Char animation
  try{ updateChar(t); }catch(e){}

  // Update bloom first so mixPass sees fresh bloomTexture
  // ------------------------ IMPORTANT ------------------------
  // Hide excluded objects so they don't contribute to bloom
  try{ hideBloomExcluded(); }catch(e){}
  // Also temporarily remove scene.background so background images don't contribute to bloom
//   let _savedBackground = null;
//   try{
//     _savedBackground = scene.background;
//     scene.background = null;
//   }catch(e){}

  bloomComposer.render();

  try{
    // restore background and excluded object visibility
    // scene.background = _savedBackground;
  }catch(e){}
  try{ restoreBloomExcluded(); }catch(e){}

  // Then render full scene and mix bloom over it to screen
  finalComposer.render();
});
</script>
</body>
</html>
